[["initialize.html", "ddRADSeq Timon Chapter 1 Initialize 1.1 INITIALIZE DIRECTORIES", " ddRADSeq Timon Adam Marques 2024-05-08 Chapter 1 Initialize 1.1 INITIALIZE DIRECTORIES Define directories. home_dir &lt;- &quot;./&quot; raw_dir &lt;- &quot;./raw/&quot; int_dir &lt;- &quot;./intermediate/&quot; Delete and create a new directory for Trimmomatic output. trim_dir &lt;- paste0(int_dir,&quot;trimmomatic/&quot;) unlink(trim_dir, force = TRUE, recursive = TRUE) dir.create(trim_dir, showWarnings = FALSE, recursive = TRUE) Delete and create a new directory for process_radtags output. radtag_dir &lt;- paste0(int_dir,&quot;process_radtags/&quot;) unlink(radtag_dir, force = TRUE, recursive = TRUE) dir.create(radtag_dir, showWarnings = FALSE, recursive = TRUE) Delete and create a new directory for denovomap output. denovo_dir &lt;- paste0(int_dir,&quot;denovomap/&quot;) unlink(denovo_dir, force = TRUE, recursive = TRUE) dir.create(denovo_dir, showWarnings = FALSE, recursive = TRUE) Delete and create a new directory for populations output. populations_dir &lt;- paste0(int_dir,&quot;populations/&quot;) unlink(populations_dir, force = TRUE, recursive = TRUE) dir.create(populations_dir, showWarnings = FALSE, recursive = TRUE) Names of your base working directories. print(c(home_dir,raw_dir,int_dir)) ## [1] &quot;./&quot; &quot;./raw/&quot; &quot;./intermediate/&quot; Cleanup rm(list=ls()) "],["trimmomatic.html", "Chapter 2 Trimmomatic 2.1 Sample Prep 2.2 Trimmomatic", " Chapter 2 Trimmomatic Define the relevant directories. ############################## ## INITIALIZE DIRECTORIES ############################## # Define directories home_dir &lt;- &quot;./&quot; raw_dir &lt;- &quot;./raw/&quot; int_dir &lt;- &quot;./intermediate/&quot; # results directories trim_dir &lt;- paste0(int_dir,&quot;trimmomatic/&quot;) radtag_dir &lt;- paste0(int_dir,&quot;process_radtags/&quot;) denovo_dir &lt;- paste0(int_dir,&quot;denovomap/&quot;) populations_dir &lt;- paste0(int_dir,&quot;populations/&quot;) 2.1 Sample Prep Read sequence records, which must include the sample name, the associated barcode index, and the corresponding name submitted to the Illumina sequencer. ############################## ## SAMPLE PREP ############################## # sample indices and barcodes read.csv(paste0(raw_dir,&quot;Timon_indices.csv&quot;)) -&gt; df_indices # index key read.table(paste0(raw_dir,&quot;index_key&quot;)) -&gt; key # Seq library read.csv(paste0(raw_dir,&quot;ddRAD_GVA1.csv&quot;),skip = 13) -&gt; df_seq Return a list of all FastQ files in a each sequence directory. Sequence directories contain all reads with a given i5 and i7 adapter pair. # list of sequence directories fq &lt;- list() list.files(path = raw_dir, pattern = &quot;MK1&quot;, include.dirs = T) -&gt; fq # save barcode to each sequence directory for (i in seq_along(fq)){ # identify sample corresponding to seq directory df_seq[df_seq$Description == fq[i],]$Sample_ID -&gt; x # match name to corresponding code df_indices[df_indices$SampleName==x, c(&quot;P1.Adapter&quot;,&quot;P2.Adapter&quot;,&quot;SampleName&quot;)] -&gt; y data.frame(v1=key[match(y$P1.Adapter, key$V1), 2], v2=key[match(y$P2.Adapter, key$V1), 2], v3=y$SampleName) -&gt; y # write barcode file for seq directory write.table(y, paste0(raw_dir,fq[i],&quot;/barcodes_&quot;,fq[i]), col.names = F, row.names = F, quote = F, sep = &quot;\\t&quot;) } Find the matching pairs of indices and sample names then generate a barcode file. # match and repalces name with sequence data.frame(v1=key[match(df_indices$P1.Adapter, key$V1), 2], v2=key[match(df_indices$P2.Adapter, key$V1), 2], v3=df_indices$SampleName) -&gt; barcodes # save data as barcode file write.table(barcodes,paste0(raw_dir,&quot;barcodes&quot;), col.names = F, row.names = F, quote = F, sep = &quot;\\t&quot;) If using a subset of samples, denovo_map will generate an error when encountering samples listed in the popmap not located among the input samples. x &lt;- list() # collect list of barcode files list.files(path = raw_dir, pattern = &quot;barcodes_&quot;, recursive = T) -&gt; barcodes for (i in seq_along(barcodes)){ read.table(paste0(raw_dir,barcodes[i]))[3] -&gt; x[i] } # write limited popmap to input write.table(cbind.data.frame(unlist(x),rep(&quot;Timon&quot;,length(x))), # assign all samples as generic Timon paste0(raw_dir,&quot;popmap&quot;), col.names = F, row.names = F, quote = F, sep = &quot;\\t&quot;) # cleanup rm(df_indices,key,barcodes,df_seq,fq,i,x,y) 2.2 Trimmomatic Trimmomatic removes adapter sequences from the single-end reads so that the PstI cut-site is situated at the start of the read. First run Trimmomatic for all reads, then again on single-end mode to remove the residual adapters before the PstI cut-site. Running without Trimmomatic appears to result in process_radtags running into an error identifying the aclI cutsit. ############################## ## Trimmomatic ############################## pattern &lt;- c(&quot;1.fq.gz&quot;,&quot;2.fq.gz&quot;) s = 1 # start character f = 6 # ending character # fastp filter options qualified_quality_phred = 15 length_required = 50 low_complexity_filter = 30 # Minimum complexity ## list fo files to run # list of sequence directories fq &lt;- list() list.files(path = raw_dir, pattern = &quot;MK1&quot;, include.dirs = T) -&gt; fq # single end p1 &lt;- list() list.files(path = raw_dir, pattern = pattern[1], recursive = T) -&gt; p1 # paired end p2 &lt;- list() list.files(path = raw_dir, pattern = pattern[2], recursive = T) -&gt; p2 Generate output directory for trimmed results for (i in seq_along(fq)){ dir.create(paste0(trim_dir,fq[i]), showWarnings = FALSE, recursive = TRUE) } Execute Trimmomatic # execute Trimmomatic for all reads for (i in seq_along(p1)){ system( paste0( # Call the function &quot;java -jar &quot;,&quot;./Trimmomatic-0.39/trimmomatic-0.39.jar&quot;, # Paired end &quot; PE &quot;, # Inputs raw_dir,p1[i],&quot; &quot;, raw_dir,p2[i],&quot; &quot;, # Outputs trim_dir,fq[i],&quot;/&quot;,fq[i],&quot;_Trim1.fq &quot;, trim_dir,fq[i],&quot;/&quot;,fq[i],&quot;_Unpair1.fq &quot;, trim_dir,fq[i],&quot;/&quot;,fq[i],&quot;_Trim2.fq &quot;, trim_dir,fq[i],&quot;/&quot;,fq[i],&quot;_Unpair2.fq &quot;, # Select adapters &quot;ILLUMINACLIP:&quot;, home_dir,&quot;./Trimmomatic-0.39/adapters/NexteraPE-PE.fa:2:30:10 &quot;, &quot;SLIDINGWINDOW:4:20 &quot;, &quot;MINLEN:150 &quot; ), intern = TRUE) # compress files system(paste0( &quot;gzip &quot;,trim_dir,fq[i],&quot;/*.fq&quot; ), intern = TRUE) } # cleanup rm(list=ls()) "],["process-radtags.html", "Chapter 3 Process Radtags", " Chapter 3 Process Radtags Raw reads are checked for barcode indices and RAD cutsite then demultiplexed. A sliding window checks the average quality score and discards those with less than 90% probability of being correct corresponding to a raw phred score of 10. ############################## ## INITIALIZE DIRECTORIES ############################## # Define directories home_dir &lt;- &quot;./&quot; raw_dir &lt;- &quot;./raw/&quot; int_dir &lt;- &quot;./intermediate/&quot; # results directories trim_dir &lt;- paste0(int_dir,&quot;trimmomatic/&quot;) radtag_dir &lt;- paste0(int_dir,&quot;process_radtags/&quot;) denovo_dir &lt;- paste0(int_dir,&quot;denovomap/&quot;) populations_dir &lt;- paste0(int_dir,&quot;populations/&quot;) Load the relevant parameters. Stacks versions 2.65+ are necessary for our analysis as earlier versions do not have the “aclI” enzyme option. ############################## ## PARAMETERS ############################## # general cutside renz1 = &quot;pstI&quot; # rare cutsite renz2 = &quot;aclI&quot; # adapter sequence lenth_limit = 150 Identify all of the trimmed files for use as imput. ############################## ## LIST FILES ############################## # list of sequence directories fq &lt;- list() list.files(path = trim_dir, pattern = &quot;MK1&quot;, include.dirs = T) -&gt; fq # trimmed P1 reads p1 &lt;- list() list.files(path = trim_dir, pattern = &quot;Trim1.fq.gz&quot;, recursive = T) -&gt; p1 # trimmer P2 reads p2 &lt;- list() list.files(path = trim_dir, pattern = &quot;Trim2.fq.gz&quot;, recursive = T) -&gt; p2 Repeat the process_radtags function for each sequence directory. All demultiplexed reads are then stored in the same directory, “process_radtags”. ############################## ## PROCESS_RADTAGS ############################## ### Run process_radtags to parse the Combined data by individual for (i in seq_along(fq)){ system( paste0(&quot;process_radtags&quot;, &quot; -1 &quot;,trim_dir,p1[i], &quot; -2 &quot;,trim_dir,p2[i], &quot; -b &quot;,raw_dir,fq[i],&quot;/barcodes_&quot;,fq[i], &quot; --paired &quot;, &quot; -c &quot;, &quot; -r &quot;, &quot; -o &quot;,radtag_dir, &quot; -q &quot;, &quot; --inline-inline &quot;, &quot; --renz-1 &quot;,renz1, &quot; --renz-2 &quot;,renz2 ), intern = TRUE) } # cleanup rm(list=ls()) "],["denovo-map.html", "Chapter 4 Denovo Map", " Chapter 4 Denovo Map The denovo_map program executes each of the steps in the Stacks pipeline individually in successive order. ############################## ## INITIALIZE DIRECTORIES ############################## # Define directories home_dir &lt;- &quot;./&quot; raw_dir &lt;- &quot;./raw/&quot; int_dir &lt;- &quot;./intermediate/&quot; # results directories trim_dir &lt;- paste0(int_dir,&quot;trimmomatic/&quot;) radtag_dir &lt;- paste0(int_dir,&quot;process_radtags/&quot;) denovo_dir &lt;- paste0(int_dir,&quot;denovomap/&quot;) populations_dir &lt;- paste0(int_dir,&quot;populations/&quot;) A population map contains assignments of each of your samples to a particular population. The number of mismatches allowed between stacks within individuals during ustacks (-M), is iterated to determine which the optimal value might be. Sequence replicates can be used in this case to identify the value with the lowest error rate, otherwise select a single value for -M. ############################## ## PARAMETERS ############################## ### load parameters # load population map pop_map = paste0(raw_dir,&quot;popmap&quot;) # number of mismatches allowed between stacks within individuals (for ustacks). M = 4 # the number of threads/CPUs to use (default: 1). Thread = 10 Run denovo_map either iteratively or at a single value. Each value of -M is save to a separate directory. # new list of directories to save results denovo_M_dir &lt;- list() ## Iterate for variable values of M for (i in seq_along(M)){ denovo_M_dir[[i]] &lt;- paste0(denovo_dir,&quot;denovo_M&quot;,M[i],&quot;/&quot;) # empty directory to save FastQ files unlink(denovo_M_dir[[i]], recursive = TRUE, force = TRUE) dir.create(denovo_M_dir[[i]], showWarnings = FALSE, recursive = TRUE) system(paste0(&quot;denovo_map.pl&quot;, &quot; -T &quot;, Thread, &quot; -M &quot;, M[i], &quot; -o &quot;, denovo_M_dir[[i]], &quot; --samples &quot;, radtag_dir, &quot; --popmap &quot;, pop_map, &quot; --paired&quot; ), intern = TRUE) } # cleanup rm(list=ls()) "],["populations.html", "Chapter 5 Populations", " Chapter 5 Populations The populations program will analyze a population of individual samples computing a number of population genetics statistics as well as exporting a variety of standard output formats. ############################## ## INITIALIZE DIRECTORIES ############################## # Define directories home_dir &lt;- &quot;./&quot; raw_dir &lt;- &quot;./raw/&quot; int_dir &lt;- &quot;./intermediate/&quot; # results directories trim_dir &lt;- paste0(int_dir,&quot;trimmomatic/&quot;) radtag_dir &lt;- paste0(int_dir,&quot;process_radtags/&quot;) denovo_dir &lt;- paste0(int_dir,&quot;denovomap/&quot;) populations_dir &lt;- paste0(int_dir,&quot;populations/&quot;) The populations program provides filtering options to only include loci or variant sites that occur at certain frequencies in each population or in the metapopulation. ############################## ## PARAMETERS ############################## ### load parameters # load population map pop_map = paste0(raw_dir,&quot;popmap&quot;) M = 4 # max mismatches allowed between stacks within individuals Thread = 10 # the number of threads/CPUs to use (default: 1). msp = 0.75 # min number of samples per population maf = 0.05 # minimum minor allele frequency moh = 0.5 # maximum observed heterozygosity # new list of directories to save results denovo_M_dir &lt;- paste0(denovo_dir,&quot;denovo_M&quot;,M,&quot;/&quot;) ## Run populations # run denovo_map system(paste0(&quot;populations&quot;, &quot; -P &quot;, denovo_M_dir, &quot; -O &quot;, populations_dir, &quot; -M &quot;, pop_map, &quot; --genepop --structure --fasta-loci&quot;, &quot; -t &quot;,Thread, &quot; --min-samples-per-pop &quot;, 0.75, &quot; --min-maf &quot;,0.05, &quot;--max-obs-het&quot;,0.5), intern = TRUE) ## Warning in system(paste0(&quot;populations&quot;, &quot; -P &quot;, denovo_M_dir, &quot; -O &quot;, populations_dir, : running command ## &#39;populations -P ./intermediate/denovomap/denovo_M4/ -O ./intermediate/populations/ -M ./raw/popmap --genepop ## --structure --fasta-loci -t 10 --min-samples-per-pop 0.75 --min-maf 0.05--max-obs-het0.5&#39; had status 1 ## [1] &quot;Logging to &#39;./intermediate/populations/populations.log&#39;.&quot; ## [2] &quot;Locus/sample distributions will be written to &#39;./intermediate/populations/populations.log.distribs&#39;.&quot; ## [3] &quot;populations parameters selected:&quot; ## [4] &quot; Percent samples limit per population: 0.75&quot; ## [5] &quot; Locus Population limit: 1&quot; ## [6] &quot; Percent samples overall: 0&quot; ## [7] &quot; Minor allele frequency cutoff: 0.05&quot; ## [8] &quot; Maximum observed heterozygosity cutoff: 1&quot; ## [9] &quot; Applying Fst correction: none.&quot; ## [10] &quot; Pi/Fis kernel smoothing: off&quot; ## [11] &quot; F-stats kernel smoothing: off&quot; ## [12] &quot; Bootstrap resampling: off&quot; ## [13] &quot;&quot; ## [14] &quot;Parsing population map...&quot; ## [15] &quot;The population map contained 3 samples, 1 population(s), 1 group(s).&quot; ## [16] &quot;Working on 3 samples.&quot; ## [17] &quot;Working on 1 population(s):&quot; ## [18] &quot; Timon: GVA1418, GVA1515, GVA1926&quot; ## [19] &quot;Working on 1 group(s) of populations:&quot; ## [20] &quot; defaultgrp: Timon&quot; ## [21] &quot;&quot; ## [22] &quot;Polymorphic sites in GenePop format will be written to &#39;./intermediate/populations/populations.snps.genepop&#39;&quot; ## [23] &quot;Polymorphic loci in GenePop format will be written to &#39;./intermediate/populations/populations.haps.genepop&#39;&quot; ## [24] &quot;Polymorphic sites in Structure format will be written to &#39;./intermediate/populations/populations.structure&#39;&quot; ## [25] &quot;FASTA consensus sequences for each locus in the metapopulation will be written to &#39;./intermediate/populations/populations.loci.fa&#39;&quot; ## [26] &quot;Raw haplotypes will be written to &#39;./intermediate/populations/populations.haplotypes.tsv&#39;&quot; ## [27] &quot;Population-level summary statistics will be written to &#39;./intermediate/populations/populations.sumstats.tsv&#39;&quot; ## [28] &quot;Population-level haplotype summary statistics will be written to &#39;./intermediate/populations/populations.hapstats.tsv&#39;&quot; ## [29] &quot;&quot; ## [30] &quot;Processing data in batches:&quot; ## [31] &quot; * load a batch of catalog loci and apply filters&quot; ## [32] &quot; * compute SNP- and haplotype-wise per-population statistics&quot; ## [33] &quot; * write the above statistics in the output files&quot; ## [34] &quot; * export the genotypes/haplotypes in specified format(s)&quot; ## [35] &quot;More details in &#39;./intermediate/populations/populations.log.distribs&#39;.&quot; ## [36] &quot;&quot; ## [37] &quot;Now processing...&quot; ## [38] &quot;Batch 1 &quot; ## [39] &quot;&quot; ## [40] &quot;Removed 195 loci that did not pass sample/population constraints from 196 loci.&quot; ## [41] &quot;Kept 1 loci, composed of 148 sites; 0 of those sites were filtered, 0 variant sites remained.&quot; ## [42] &quot;Number of loci with PE contig: 1.00 (100.0%);&quot; ## [43] &quot; Mean length of loci: 138.00bp (stderr inf);&quot; ## [44] &quot;Number of loci with SE/PE overlap: 1.00 (100.0%);&quot; ## [45] &quot; Mean length of overlapping loci: 148.00bp (stderr -nan); mean overlap: 31.00bp (stderr -nan);&quot; ## [46] &quot;Mean genotyped sites per locus: 148.00bp (stderr -nan).&quot; ## [47] &quot;&quot; ## [48] &quot;Population summary statistics (more detail in populations.sumstats_summary.tsv):&quot; ## [49] &quot; Timon: -nan samples per locus; pi: -nan; all/variant/polymorphic sites: 148/0/0; private alleles: 0&quot; ## attr(,&quot;status&quot;) ## [1] 1 # cleanup rm(list=ls()) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
